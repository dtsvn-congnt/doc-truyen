<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>M√°y ƒê·ªçc (V21.1 - Fix N√∫t)</title>
    <style>
        :root { --bg-body: #eef2f3; --bg-container: #ffffff; --text-main: #333333; --text-sub: #666666; --border-color: #dddddd; --box-bg: #ffffff; --ctx-prev-color: #888888; --ctx-next-color: #555555; --hl-bg: #fff3cd; --hl-border: #ffc107; --hl-text: #856404; --progress-bg: #f8f9fa; }
        [data-theme="dark"] { --bg-body: #000000; --bg-container: #121212; --text-main: #e0e0e0; --text-sub: #aaaaaa; --border-color: #333333; --box-bg: #1e1e1e; --ctx-prev-color: #777777; --ctx-next-color: #cccccc; --hl-bg: #3a3000; --hl-border: #665c00; --hl-text: #ffd54f; --progress-bg: #2c2c2c; }
        
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: var(--bg-body); color: var(--text-main); margin: 0; padding: 20px; transition: background 0.3s; min-height: 100vh; }
        .container { background: var(--bg-container); padding: 20px; border-radius: 12px; box-shadow: 0 6px 15px rgba(0,0,0,0.1); width: 100%; max-width: 650px; text-align: center; box-sizing: border-box; padding-bottom: 80px; /* Ch·ª´a ch·ªó cho n√∫t */ }
        
        @media (max-width: 768px) {
            body { padding: 0; } 
            .container { border-radius: 0; box-shadow: none; min-height: 100vh; padding: 15px; padding-bottom: 100px; /* TƒÉng kho·∫£ng tr·ªëng ƒë√°y mobile */ }
        }

        input[type="text"] { width: 100%; padding: 12px; margin-bottom: 15px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--box-bg); color: var(--text-main); box-sizing: border-box; }
        .control-group { margin: 10px 0; display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; }
        button { padding: 12px 15px; cursor: pointer; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; flex: 1; max-width: 120px; white-space: nowrap; }
        .btn-blue { background: #007bff; } .btn-red { background: #dc3545; } .btn-gray { background: #6c757d; } 
        
        /* N√∫t ch∆∞∆°ng sau: Lu√¥n hi·ªán */
        .btn-green { background: #28a745; width: 100%; margin-top: 15px; max-width: none; padding: 15px; font-size: 18px; }
        .btn-green:disabled { background: #cccccc; cursor: not-allowed; opacity: 0.7; }

        .btn-theme { background: transparent; border: 1px solid var(--text-sub); color: var(--text-main); padding: 5px 10px; font-size: 12px; margin-bottom: 10px; border-radius: 20px; flex: none; width: auto; }

        .progress-wrapper { background: var(--progress-bg); padding: 12px; border-radius: 8px; margin: 15px 0; border: 1px solid var(--border-color); }
        input[type="range"] { width: 100%; cursor: pointer; margin: 10px 0; height: 20px; }
        
        #readingBox { margin-top: 15px; padding: 15px; background: var(--box-bg); border: 1px solid var(--border-color); border-radius: 8px; text-align: left; min-height: 200px; display: flex; flex-direction: column; justify-content: center; }
        .ctx-prev, .ctx-next { font-size: 15px; color: var(--text-sub); opacity: 0.6; padding: 4px 10px; }
        .ctx-current { color: var(--hl-text); font-size: 21px; font-weight: 700; line-height: 1.5; background: var(--hl-bg); padding: 15px; border-radius: 8px; border-left: 5px solid var(--hl-border); margin: 8px 0; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }

        .switch-container { display: flex; align-items: center; justify-content: center; margin-top: 15px; gap: 10px; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; } input:checked + .slider:before { transform: translateX(26px); }
    </style>
</head>
<body>

    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; color: var(--text-main);">üìñ M√°y ƒê·ªçc V21.1</h3>
            <button onclick="toggleTheme()" class="btn-theme" id="themeBtn">üåô T·ªëi</button>
        </div>
        
        <input type="text" id="urlInput" placeholder="D√°n link chapter truy·ªán...">
        
        <div class="control-group">
            <button onclick="manualSeek(-1)" class="btn-gray">‚è™ L√πi</button>
            <button onclick="handlePlayButton()" id="btnStart" class="btn-blue">‚ñ∂ ƒê·ªåC</button>
            <button onclick="handleStopButton()" class="btn-red">‚èπ STOP</button>
            <button onclick="manualSeek(1)" class="btn-gray">Ti·∫øn ‚è©</button>
        </div>

        <div class="progress-wrapper">
            <div style="display:flex; justify-content:space-between; font-size:14px; color: var(--text-sub);">
                <span id="progressLabel">0/0</span>
                <span><span id="speedLabel" style="color: #dc3545;">1.0x</span></span>
            </div>
            <input type="range" id="progressBar" min="0" value="0" step="1" oninput="seekToBar()">
            <div style="margin-top:5px; text-align: center;">
                <input type="range" id="speedInput" min="0.5" max="2.0" step="0.25" value="1.0" style="width: 100px;">
            </div>
        </div>

        <div id="readingBox">
            <div style="text-align: center; color: var(--text-sub);">S·∫µn s√†ng...</div>
        </div>
        
        <div id="statusLog" style="font-size: 13px; color: #666; margin-top: 10px;"></div>

        <div class="switch-container">
            <label class="switch">
                <input type="checkbox" id="useGoogleOnline" checked>
                <span class="slider"></span>
            </label>
            <span style="font-size: 14px; font-weight: bold; color: var(--text-main);">Online (Google Proxy)</span>
        </div>

        <button onclick="goToNext()" id="btnNext" class="btn-green" disabled>‚è≠ CH∆ØA C√ì LINK SAU</button>
        <input type="hidden" id="nextUrlHidden">
        
        <div style="margin-top: 15px; font-size: 14px;">
            <input type="checkbox" id="autoNext" checked> <label for="autoNext" style="color: var(--text-main)">T·ª± ƒë·ªông chuy·ªÉn ch∆∞∆°ng</label>
        </div>
    </div>

    <script>
        const urlInput = document.getElementById('urlInput');
        const readingBox = document.getElementById('readingBox');
        const statusLog = document.getElementById('statusLog');
        const progressBar = document.getElementById('progressBar');
        const progressLabel = document.getElementById('progressLabel');
        const speedInput = document.getElementById('speedInput');
        const nextUrlInput = document.getElementById('nextUrlHidden');
        const btnNext = document.getElementById('btnNext');
        const btnStart = document.getElementById('btnStart');
        const themeBtn = document.getElementById('themeBtn');
        const checkGoogle = document.getElementById('useGoogleOnline');

        window.synth = window.speechSynthesis;
        window.uttr = null;
        let audioPlayer = new Audio();
        let wakeLock = null;
        
        let state = { sentences: [], index: 0, subIndex: 0, isReading: false, dataLoaded: false };
        let audioCache = new Map(); 
        const PRELOAD_LIMIT = 2; 

        function processContent(fullText) {
            if (!fullText) return [];
            let clean = fullText.replace(/\.\.+/g, '.');
            let rawSentences = clean.replace(/([.?!;\n]+[‚Äù"']*)/g, "$1|").split("|").map(s => s.trim()).filter(s => s.length > 0);
            let finalData = [];
            rawSentences.forEach(sentence => {
                let chunks = [];
                if (sentence.length > 180) { chunks = splitLongString(sentence); } 
                else { chunks = [sentence]; }
                if (/[a-zA-Z0-9\u00C0-\u1EF9]/.test(sentence)) {
                    finalData.push({ text: sentence, chunks: chunks });
                }
            });
            return finalData;
        }

        function splitLongString(text) {
            let parts = [];
            let temp = text.replace(/(,[‚Äù"']*)\s/g, "$1|"); 
            let arr = temp.split("|");
            arr.forEach(s => {
                s = s.trim();
                if (!s) return;
                if (s.length > 180) {
                    let mid = Math.floor(s.length / 2);
                    let splitIndex = s.indexOf(' ', mid);
                    if (splitIndex !== -1) { parts.push(s.substring(0, splitIndex)); parts.push(s.substring(splitIndex + 1)); } 
                    else { parts.push(s); }
                } else { parts.push(s); }
            });
            return parts;
        }

        async function fetchAudioBlob(text) {
            try {
                const response = await fetch(`/api/tts?text=${encodeURIComponent(text)}`);
                if (!response.ok) throw new Error("Err");
                const blob = await response.blob();
                return URL.createObjectURL(blob); 
            } catch (e) { return null; }
        }

        async function manageCache(currentIndex) {
            for (let i = currentIndex; i < Math.min(currentIndex + PRELOAD_LIMIT, state.sentences.length); i++) {
                let sentenceObj = state.sentences[i];
                sentenceObj.chunks.forEach((chunkText, chunkIdx) => {
                    let key = `${i}_${chunkIdx}`;
                    if (!audioCache.has(key)) { fetchAudioBlob(chunkText).then(url => { if (url) audioCache.set(key, url); }); }
                });
            }
            for (let i = 0; i < currentIndex - 1; i++) {
                 let sentenceObj = state.sentences[i];
                 sentenceObj.chunks.forEach((_, cIdx) => {
                     let key = `${i}_${cIdx}`;
                     if (audioCache.has(key)) { URL.revokeObjectURL(audioCache.get(key)); audioCache.delete(key); }
                 });
            }
        }

        async function playNextSentence() {
            if (!state.isReading) return;
            if (state.index >= state.sentences.length) { onFinishChapter(); return; }

            updateReadingBoxUI();
            updateProgressBar();

            const currentObj = state.sentences[state.index];
            
            if (checkGoogle.checked) {
                manageCache(state.index); 
                if (state.subIndex >= currentObj.chunks.length) {
                    state.index++; state.subIndex = 0; playNextSentence(); return;
                }

                let chunkText = currentObj.chunks[state.subIndex];
                let key = `${state.index}_${state.subIndex}`;
                let audioUrl = audioCache.get(key);

                if (!audioUrl) {
                    statusLog.innerText = `‚è≥ T·∫£i ƒëo·∫°n ${state.subIndex + 1}...`;
                    audioUrl = await fetchAudioBlob(chunkText);
                    if (audioUrl) audioCache.set(key, audioUrl);
                }

                if (audioUrl) {
                    statusLog.innerText = "‚ñ∂ ƒêang ƒë·ªçc...";
                    audioPlayer.src = audioUrl;
                    audioPlayer.playbackRate = parseFloat(speedInput.value);
                    
                    audioPlayer.play().catch(e => {
                        console.error("Block:", e);
                        setTimeout(() => { if(state.isReading) { state.subIndex++; playNextSentence(); }}, 500);
                    });

                    audioPlayer.onended = () => { if (state.isReading) { state.subIndex++; playNextSentence(); } };
                    audioPlayer.onerror = () => { if (state.isReading) { state.subIndex++; playNextSentence(); } };
                } else { state.subIndex++; playNextSentence(); }

            } else {
                speakNative(currentObj.text);
            }
        }

        function speakNative(text) {
            window.synth.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            let voices = window.synth.getVoices();
            let voice = voices.find(v => v.lang.includes('vi'));
            if (voice) utterance.voice = voice;
            utterance.rate = parseFloat(speedInput.value);
            utterance.lang = 'vi-VN';
            utterance.onend = () => { if (state.isReading) { state.index++; state.subIndex = 0; playNextSentence(); } };
            utterance.onerror = (e) => { if (e.error !== 'interrupted' && state.isReading) { state.index++; playNextSentence(); } };
            window.uttr = utterance;
            window.synth.speak(utterance);
        }

        function updateReadingBoxUI() {
            const i = state.index;
            const s = state.sentences;
            let html = '';
            if (i > 0) html += `<div class="ctx-prev">${s[i - 1].text}</div>`;
            html += `<div class="ctx-current">${s[i].text}</div>`;
            if (i < s.length - 1) html += `<div class="ctx-next">${s[i + 1].text}</div>`;
            if (i < s.length - 2) html += `<div class="ctx-next">${s[i + 2].text}</div>`;
            readingBox.innerHTML = html;
        }

        function updateProgressBar() { progressBar.value = state.index; progressLabel.innerText = `${state.index + 1}/${state.sentences.length}`; }

        function unlockAudio() {
            if (window.synth && !window.synth.speaking) { const u = new SpeechSynthesisUtterance(" "); u.volume=0; window.synth.speak(u); }
            audioPlayer.play().catch(()=>{}); audioPlayer.pause();
        }

        async function handlePlayButton() {
            unlockAudio(); requestWakeLock();
            const url = urlInput.value;
            if (!url) { alert("Thi·∫øu Link!"); return; }
            if (state.dataLoaded && !state.isReading) { state.isReading = true; playNextSentence(); return; }
            if (!state.dataLoaded) await fetchAndStart(url);
        }

        function handleStopButton() {
            state.isReading = false;
            if (window.uttr) window.uttr.onend = null; window.synth.cancel();
            audioPlayer.pause(); audioPlayer.onended = null;
            statusLog.innerText = "‚èπ ƒê√£ d·ª´ng.";
            if (wakeLock) { wakeLock.release(); wakeLock = null; }
            audioCache.forEach(url => URL.revokeObjectURL(url)); audioCache.clear();
        }

        function manualSeek(step) {
            if (!state.dataLoaded) return;
            handleStopButton();
            state.index += step; state.subIndex = 0;
            if (state.index < 0) state.index = 0;
            if (state.index >= state.sentences.length) state.index = state.sentences.length - 1;
            state.isReading = true; unlockAudio(); playNextSentence(); 
        }

        function seekToBar() {
            if (!state.dataLoaded) return;
            handleStopButton();
            state.index = parseInt(progressBar.value); state.subIndex = 0;
            state.isReading = true; unlockAudio(); playNextSentence();
        }

        async function fetchAndStart(url) {
            handleStopButton(); btnStart.disabled = true; statusLog.innerText = "‚è≥ ƒêang t·∫£i...";
            try {
                const response = await fetch(`/api/speak?url=${encodeURIComponent(url)}`);
                const data = await response.json();
                state.sentences = processContent(data.content);
                if (state.sentences.length === 0) throw new Error("Kh√¥ng c√≥ n·ªôi dung");
                
                state.index = 0; state.subIndex = 0; state.dataLoaded = true; state.isReading = true;
                progressBar.max = state.sentences.length - 1; progressBar.value = 0;
                
                // LOGIC N√öT CHUY·ªÇN T·∫¨P
                if (data.nextLink) { 
                    nextUrlInput.value = data.nextLink; 
                    btnNext.innerText = "‚è≠ CH∆Ø∆†NG SAU (C√≥ s·∫µn)";
                    btnNext.disabled = false;
                } else { 
                    nextUrlInput.value = ""; 
                    btnNext.innerText = "‚õî KH√îNG C√ì LINK SAU";
                    btnNext.disabled = true;
                }
                
                btnStart.disabled = false; unlockAudio(); playNextSentence(); 
            } catch (err) { readingBox.innerText = "‚ùå L·ªói: " + err.message; statusLog.innerText = "L·ªói t·∫£i trang."; btnStart.disabled = false; }
        }

        function toggleTheme() {
            const body = document.body;
            if (body.getAttribute('data-theme') === 'dark') { body.removeAttribute('data-theme'); themeBtn.innerText = "üåô T·ªëi"; } 
            else { body.setAttribute('data-theme', 'dark'); themeBtn.innerText = "‚òÄÔ∏è S√°ng"; }
        }
        async function requestWakeLock() { try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch (e) {} }
        speedInput.oninput = function() { document.getElementById('speedLabel').innerText = this.value + 'x'; };
        function onFinishChapter() {
            const isAuto = document.getElementById('autoNext').checked;
            const nextLink = nextUrlInput.value;
            if (isAuto && nextLink) { statusLog.innerText = "‚è≠ Chuy·ªÉn ch∆∞∆°ng..."; goToNext(); }
            else { statusLog.innerText = "‚úÖ H·∫øt ch∆∞∆°ng."; state.isReading = false; }
        }
        function goToNext() {
            const nextLink = nextUrlInput.value;
            if (nextLink) { state.dataLoaded = false; urlInput.value = nextLink; handlePlayButton(); }
        }
    </script>
</body>
</html>