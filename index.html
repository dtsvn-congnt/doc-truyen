<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√°y ƒê·ªçc Truy·ªán (V11 Auto Loop)</title>
    <style>
        /* --- 1. C·∫§U H√åNH M√ÄU S·∫ÆC --- */
        :root {
            --bg-body: #eef2f3;
            --bg-container: #ffffff;
            --text-main: #333333;
            --text-sub: #666666;
            --border-color: #dddddd;
            --box-bg: #ffffff;
            --ctx-prev-color: #888888;
            --ctx-next-color: #555555;
            --hl-bg: #fff3cd;
            --hl-border: #ffc107;
            --hl-text: #856404;
            --progress-bg: #f8f9fa;
        }

        /* DARK MODE */
        [data-theme="dark"] {
            --bg-body: #121212;
            --bg-container: #1e1e1e;
            --text-main: #e0e0e0;
            --text-sub: #aaaaaa;
            --border-color: #333333;
            --box-bg: #252525;
            --ctx-prev-color: #777777;
            --ctx-next-color: #cccccc;
            --hl-bg: #3a3000; 
            --hl-border: #665c00;
            --hl-text: #ffd54f;
            --progress-bg: #2c2c2c;
        }

        /* --- 2. CSS CHUNG --- */
        body { 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 20px; 
            background: var(--bg-body); 
            color: var(--text-main);
            transition: background 0.3s, color 0.3s;
        }
        
        .container { 
            background: var(--bg-container); 
            padding: 20px; border-radius: 12px; 
            box-shadow: 0 6px 15px rgba(0,0,0,0.2); 
            width: 95%; max-width: 650px; text-align: center; 
            transition: background 0.3s;
        }
        
        input[type="text"] { 
            width: 100%; padding: 12px; margin-bottom: 15px; border-radius: 8px; 
            border: 1px solid var(--border-color); 
            background: var(--bg-container);
            color: var(--text-main);
            box-sizing: border-box; 
        }

        /* N√∫t b·∫•m */
        .control-group { margin: 10px 0; display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; }
        button { padding: 10px 18px; cursor: pointer; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; transition: 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:disabled { background: #555 !important; cursor: not-allowed; opacity: 0.5; }
        
        .btn-blue { background: #007bff; min-width: 100px; }
        .btn-red { background: #dc3545; }
        .btn-gray { background: #6c757d; }
        .btn-green { background: #28a745; width: 100%; display: none; margin-top: 15px; padding: 12px; }
        
        .btn-theme { 
            background: transparent; border: 1px solid var(--text-sub); 
            color: var(--text-main); padding: 5px 10px; font-size: 12px; 
            margin-bottom: 10px; border-radius: 20px;
        }

        /* Thanh ti·∫øn ƒë·ªô */
        .progress-wrapper { 
            background: var(--progress-bg); 
            padding: 12px; border-radius: 8px; margin: 15px 0; 
            border: 1px solid var(--border-color); 
        }
        input[type="range"] { width: 100%; cursor: pointer; margin: 10px 0; }
        .info-label { display:flex; justify-content:space-between; font-size:14px; font-weight:bold; color: var(--text-sub); }

        /* KHUNG ƒê·ªåC */
        #readingBox { 
            margin-top: 15px; padding: 15px; 
            background: var(--box-bg); 
            border: 1px solid var(--border-color); border-radius: 8px; 
            text-align: left; max-height: 450px; overflow-y: auto;
            transition: background 0.3s;
        }

        .ctx-prev { 
            color: var(--ctx-prev-color); font-size: 16px; margin-bottom: 10px; padding-left: 10px; border-left: 3px solid var(--border-color); 
        }
        .ctx-current { 
            color: var(--hl-text); font-size: 20px; font-weight: 600; line-height: 1.6;
            background: var(--hl-bg); padding: 15px; border-radius: 8px; 
            border-left: 5px solid var(--hl-border); margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .ctx-next { 
            color: var(--ctx-next-color); font-size: 17px; margin-top: 10px; padding-left: 10px; border-left: 3px solid var(--border-color); 
        }

        #statusLog { font-size: 13px; color: var(--text-sub); margin-top: 10px; font-style: italic; min-height: 20px; }
    </style>
</head>
<body>

    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; color: var(--text-main);">üìñ M√°y ƒê·ªçc Truy·ªán</h3>
            <button onclick="toggleTheme()" class="btn-theme" id="themeBtn">üåô Ch·∫ø ƒë·ªô t·ªëi</button>
        </div>
        
        <input type="text" id="urlInput" placeholder="D√°n link chapter truy·ªán v√†o ƒë√¢y...">
        
        <div class="control-group">
            <button onclick="manualSeek(-1)" class="btn-gray">‚è™ L√πi</button>
            <button onclick="handlePlayButton()" id="btnStart" class="btn-blue">‚ñ∂ ƒê·ªåC</button>
            <button onclick="handleStopButton()" class="btn-red">‚èπ D·ª™NG</button>
            <button onclick="manualSeek(1)" class="btn-gray">Ti·∫øn ‚è©</button>
        </div>

        <div class="progress-wrapper">
            <div class="info-label">
                <span id="progressLabel">C√¢u: 0 / 0</span>
                <span>T·ªëc ƒë·ªô: <span id="speedLabel" style="color: #dc3545;">1.0x</span></span>
            </div>
            <input type="range" id="progressBar" min="0" value="0" step="1" oninput="seekToBar()">
            <div style="margin-top:5px; text-align: center;">
                <input type="range" id="speedInput" min="0.5" max="2.5" step="0.1" value="1.0" style="width: 100px;">
            </div>
        </div>

        <div id="readingBox">S·∫µn s√†ng...</div>
        <div id="statusLog"></div>

        <button onclick="goToNext()" id="btnNext" class="btn-green">‚è≠ CHUY·ªÇN CH∆Ø∆†NG SAU</button>

        <input type="hidden" id="nextUrlHidden">
        <div style="margin-top: 15px; font-size: 14px;">
            <input type="checkbox" id="autoNext" checked> <label for="autoNext" style="color: var(--text-main)">T·ª± ƒë·ªông chuy·ªÉn ch∆∞∆°ng</label>
        </div>
    </div>

    <script>
        // --- 1. BI·∫æN TO√ÄN C·ª§C ---
        const urlInput = document.getElementById('urlInput');
        const readingBox = document.getElementById('readingBox');
        const statusLog = document.getElementById('statusLog');
        const progressBar = document.getElementById('progressBar');
        const progressLabel = document.getElementById('progressLabel');
        const speedInput = document.getElementById('speedInput');
        const nextUrlInput = document.getElementById('nextUrlHidden');
        const btnNext = document.getElementById('btnNext');
        const btnStart = document.getElementById('btnStart');
        const themeBtn = document.getElementById('themeBtn');

        window.synth = window.speechSynthesis;
        window.uttr = null; 
        let wakeLock = null;

        let state = {
            sentences: [], index: 0, isReading: false, dataLoaded: false
        };

        // --- 2. H√ÄM CH·∫æ ƒê·ªò T·ªêI ---
        function toggleTheme() {
            const body = document.body;
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                themeBtn.innerText = "üåô Ch·∫ø ƒë·ªô t·ªëi";
            } else {
                body.setAttribute('data-theme', 'dark');
                themeBtn.innerText = "‚òÄÔ∏è Ch·∫ø ƒë·ªô s√°ng";
            }
        }

        // --- 3. WAKE LOCK ---
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('‚úÖ Wake Lock active');
                }
            } catch (err) { console.error('Wake Lock Error', err); }
        }

        // --- 4. H√ÄM ƒê·ªåC C·ªêT L√ïI (FIXED) ---
        function speakCurrentSentence() {
            if (!state.isReading) return;
            
            // N·∫øu h·∫øt b√†i
            if (state.index >= state.sentences.length) {
                onFinishChapter();
                return;
            }

            // C·∫≠p nh·∫≠t giao di·ªán
            updateReadingBoxUI();
            updateProgressBar();

            const text = state.sentences[state.index];
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.voice = getVoice();
            utterance.rate = parseFloat(speedInput.value);
            utterance.lang = 'vi-VN';

            // --- S·ª∞ KI·ªÜN QUAN TR·ªåNG: ƒê·ªåC XONG C√ÇU ---
            utterance.onend = () => {
                // Ch·ªâ c·∫ßn ƒëang ·ªü ch·∫ø ƒë·ªô ƒë·ªçc th√¨ T·ª∞ ƒê·ªòNG next c√¢u ti·∫øp theo
                // Kh√¥ng quan t√¢m l√† do t·ª± ƒë·ªçc hay do b·∫•m n√∫t Ti·∫øn/L√πi
                if (state.isReading) {
                    state.index++;
                    speakCurrentSentence(); // ƒê·ªá quy
                }
            };

            utterance.onerror = (e) => {
                if (e.error === 'interrupted') return;
                // N·∫øu l·ªói c·ª© nh·∫£y ti·∫øp
                if (state.isReading) {
                    state.index++;
                    speakCurrentSentence();
                }
            };

            // L∆∞u bi·∫øn to√†n c·ª•c v√† ph√°t
            window.uttr = utterance;
            window.synth.speak(utterance);
        }

        // --- 5. H√ÄM TUA (ƒê√É S·ª¨A L·ªñI D·ª™NG) ---
        function manualSeek(step) {
            if (!state.dataLoaded) return;

            // 1. Ng·∫Øt s·ª± ki·ªán c·ªßa c√¢u c≈© ƒë·ªÉ tr√°nh xung ƒë·ªôt
            if (window.uttr) window.uttr.onend = null;
            window.synth.cancel();

            // 2. C·∫≠p nh·∫≠t v·ªã tr√≠ m·ªõi
            state.index += step;
            if (state.index < 0) state.index = 0;
            if (state.index >= state.sentences.length) state.index = state.sentences.length - 1;

            // 3. B·∫Øt bu·ªôc b·∫≠t ch·∫ø ƒë·ªô ƒë·ªçc v√† ch·∫°y ti·∫øp
            state.isReading = true; 
            speakCurrentSentence(); 
        }

        function seekToBar() {
            if (!state.dataLoaded) return;

            if (window.uttr) window.uttr.onend = null;
            window.synth.cancel();

            state.index = parseInt(progressBar.value);
            state.isReading = true;
            speakCurrentSentence();
        }

        // --- 6. C√ÅC H√ÄM PH·ª§ TR·ª¢ ---
        function updateReadingBoxUI() {
            if (state.sentences.length === 0) return;
            let html = '';
            
            if (state.index > 0) html += `<div class="ctx-prev">${state.sentences[state.index - 1]}</div>`;
            html += `<div class="ctx-current">${state.sentences[state.index]}</div>`;
            if (state.index + 1 < state.sentences.length) html += `<div class="ctx-next">${state.sentences[state.index + 1]}</div>`;
            if (state.index + 2 < state.sentences.length) html += `<div class="ctx-next">${state.sentences[state.index + 2]}</div>`;
            
            readingBox.innerHTML = html;
            const currentEl = document.querySelector('.ctx-current');
            if(currentEl) currentEl.scrollIntoView({behavior: "smooth", block: "center"});
        }

        function splitTextSmart(text) {
            if (!text) return [];
            let clean = text.replace(/\.\.+/g, '.');
            clean = clean.replace(/([.?!;\n]+[‚Äù"']*)/g, "$1|");
            return clean.split("|").map(s => s.trim()).filter(s => {
                const hasLetters = /[a-zA-Z0-9\u00C0-\u1EF9]/.test(s);
                return s.length > 0 && hasLetters;
            });
        }

        async function handlePlayButton() {
            const url = urlInput.value;
            if (!url) { alert("Thi·∫øu Link!"); return; }
            requestWakeLock();

            if (state.dataLoaded && !state.isReading) {
                state.isReading = true;
                speakCurrentSentence();
                updateStatus("‚ñ∂ ƒêang ƒë·ªçc ti·∫øp...");
                return;
            }
            if (!state.dataLoaded) await fetchAndStart(url);
        }

        function handleStopButton() {
            state.isReading = false;
            // Ng·∫Øt s·ª± ki·ªán ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng nh·∫£y lung tung
            if (window.uttr) window.uttr.onend = null;
            window.synth.cancel();
            
            updateStatus("‚èπ ƒê√£ d·ª´ng.");
            if (wakeLock !== null) { wakeLock.release().then(() => { wakeLock = null; }); }
        }

        async function fetchAndStart(url) {
            handleStopButton();
            btnStart.disabled = true;
            updateStatus("‚è≥ ƒêang t·∫£i d·ªØ li·ªáu...");

            try {
                const response = await fetch(`/api/speak?url=${encodeURIComponent(url)}`);
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || "L·ªói server");

                state.sentences = splitTextSmart(data.content);
                if (state.sentences.length === 0) throw new Error("Kh√¥ng c√≥ n·ªôi dung");

                state.index = 0;
                state.dataLoaded = true;
                state.isReading = true;

                progressBar.max = state.sentences.length - 1;
                progressBar.value = 0;
                
                if (data.nextLink) {
                    nextUrlInput.value = data.nextLink;
                    btnNext.style.display = 'block';
                    btnNext.innerText = "‚è≠ CH∆Ø∆†NG SAU (C√≥ s·∫µn)";
                } else {
                    nextUrlInput.value = "";
                    btnNext.style.display = 'none';
                }

                btnStart.disabled = false;
                requestWakeLock(); 
                speakCurrentSentence();

            } catch (err) {
                readingBox.innerText = "‚ùå L·ªói: " + err.message;
                updateStatus("L·ªói t·∫£i trang.");
                btnStart.disabled = false;
            }
        }

        function updateProgressBar() {
            progressBar.value = state.index;
            progressLabel.innerText = `C√¢u: ${state.index + 1} / ${state.sentences.length}`;
        }
        function updateStatus(msg) { statusLog.innerText = msg; }
        
        function getVoice() {
            const voices = window.synth.getVoices();
            return voices.find(v => v.lang.includes('vi')) || voices[0];
        }
        if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = getVoice;
        
        speedInput.oninput = function() { document.getElementById('speedLabel').innerText = this.value + 'x'; };

        window.addEventListener('load', () => window.synth.cancel());
        window.addEventListener('beforeunload', () => window.synth.cancel());
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') requestWakeLock();
        });

        function onFinishChapter() {
            const isAuto = document.getElementById('autoNext').checked;
            const nextLink = nextUrlInput.value;
            if (isAuto && nextLink) { updateStatus("‚è≠ Chuy·ªÉn ch∆∞∆°ng..."); goToNext(); }
            else { updateStatus("‚úÖ H·∫øt ch∆∞∆°ng."); state.isReading = false; }
        }

        function goToNext() {
            const nextLink = nextUrlInput.value;
            if (nextLink) { state.dataLoaded = false; urlInput.value = nextLink; handlePlayButton(); }
        }
    </script>
</body>
</html>